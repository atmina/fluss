//HintName: Selectors.g.cs
// <auto-generated/>

#nullable enable

using System;
using System.Runtime.CompilerServices;

namespace Fluss
{
    public static class UnitOfWorkSelectors
    {
        private static global::Microsoft.Extensions.Caching.Memory.MemoryCache _cache = new (new global::Microsoft.Extensions.Caching.Memory.MemoryCacheOptions { SizeLimit = 1024 });

        public static async global::System.Threading.Tasks.ValueTask<global::TestNamespace.TestCrud.ReadModel> SelectTestCrud(this global::Fluss.IUnitOfWork unitOfWork, 
            string id
        )
        {
            var recordingUnitOfWork = new global::Fluss.UnitOfWorkRecordingProxy(unitOfWork);
            var key = (
                "global::TestNamespace.TestCrud.GetTestCrud",
                id
            );

            if (_cache.TryGetValue(key, out var result) && result is CacheEntryValue entryValue && await MatchesEventListenerState(unitOfWork, entryValue)) {
                return (global::TestNamespace.TestCrud.ReadModel)entryValue.Value;
            }

            result = await global::TestNamespace.TestCrud.GetTestCrud(
                recordingUnitOfWork,
                id
            ).ConfigureAwait(false);

            using (var entry = _cache.CreateEntry(key)) {
                entry.Value = new CacheEntryValue(result, recordingUnitOfWork.GetRecordedListeners());
                entry.Size = 1;
            }

            return (global::TestNamespace.TestCrud.ReadModel)result;
        }

        public static async global::System.Threading.Tasks.ValueTask<global::System.Collections.Generic.IReadOnlyList<global::TestNamespace.TestCrud.ReadModel>> SelectAllTestCruds(this global::Fluss.IUnitOfWork unitOfWork
        )
        {
            var recordingUnitOfWork = new global::Fluss.UnitOfWorkRecordingProxy(unitOfWork);
            var key = (
                "global::TestNamespace.TestCrud.GetAllTestCruds"
            );

            if (_cache.TryGetValue(key, out var result) && result is CacheEntryValue entryValue && await MatchesEventListenerState(unitOfWork, entryValue)) {
                return (global::System.Collections.Generic.IReadOnlyList<global::TestNamespace.TestCrud.ReadModel>)entryValue.Value;
            }

            result = await global::TestNamespace.TestCrud.GetAllTestCruds(
                recordingUnitOfWork
            ).ConfigureAwait(false);

            using (var entry = _cache.CreateEntry(key)) {
                entry.Value = new CacheEntryValue(result, recordingUnitOfWork.GetRecordedListeners());
                entry.Size = 1;
            }

            return (global::System.Collections.Generic.IReadOnlyList<global::TestNamespace.TestCrud.ReadModel>)result;
        }
        private record CacheEntryValue(object Value, global::System.Collections.Generic.IReadOnlyList<global::Fluss.UnitOfWorkRecordingProxy.EventListenerTypeWithKeyAndVersion>? EventListeners);

        private static async global::System.Threading.Tasks.ValueTask<bool> MatchesEventListenerState(global::Fluss.IUnitOfWork unitOfWork, CacheEntryValue value) {
            foreach (var eventListenerData in value.EventListeners ?? global::System.Array.Empty<global::Fluss.UnitOfWorkRecordingProxy.EventListenerTypeWithKeyAndVersion>()) {
                if (!await eventListenerData.IsStillUpToDate(unitOfWork)) {
                    return false;
                }
            }
            return true;
        }
    }
}

